\subsection{Profiling Tests}
\label{sec:520}

Apart from the path tracer test case, some small samples were created to have some more practical knowledge on the workflow and implementation details of each profiler. These samples, although not providing direct results, were useful to understand some of the important features and drawbacks from each available option. This section explains the observed pros and cons. Note that actual results measured from this samples were mostly useless, and so were excluded from the document.

\subsubsection{Command Line Profiler}
\label{sec:521}

As already stated in \cref{sec:330}, this profiler benefits the most from its usage simplicity. No code changes or recompilations are required whatsoever, and by measuring the right counters, it is possible to identify some possible bottlenecks, and only then move to a more deep profiling methodology.

Of course, that simplicity can sometimes be too much, preventing more customized profiling to be done. The output is also pretty much raw data, requiring some external manipulation (manual or by scripting for example). It becomes especially messy when dealing with multiple calls for different kernels in the same execution.

\subsubsection{CUPTI}
\label{sec:522}

In a naive approach, can be used to achieve the exact same result as the Command Line Profiler, but of course, that's not where it excels. By using CUPTI, the programmer is directly dealing with the API calls for the CUDA driver, and has access to low level options that allow deep levels of customization. The Callback API is particularly useful when using more complex and heterogeneous applications, where multiple kernels are being profiled at the same time. Each kernel can have specific optimization approaches (e.g. eliminate divergence, maximize occupancy, optimize memory usage), and the programmer can use that knowledge to is advantage, by measuring each kernel exactly how he wants, using different event sets for each one.
Runtime data manipulation can also be done, since counter values are immediately available, instead of being dumped to a file.

Overall, it is the most versatile of all profilers tested. The main drawback being the more difficult usage, since the code written deals directly with the driver, meaning that some low level knowledge of the architecture and the environment is even more essential.

\subsubsection{Visual Profiler}
\label{sec:523}

The potentialities of the Visual Profiler do not exceed those of the Command Line Profiler, much less those of CUPTI, at least regarding the quality and accuracy of the results obtained. While it has some very strong points in the automatic operations performed, the counters available and the data retrieved is limited.

The profiler counters are available in a similar way to that of the command line, yet a window presents all the available counters in the current hardware, saving the programmer the trouble of finding them.

Counter conflicts are dealt by the Visual Profiler by performing several runs of the application, thus obtaining the most complete image of the application with very low effort.

Lastly, while a GUI and the automatisms implemented save a lot of effort to the programmer, the learning curve is less steep. Customization may be easier to achieve with this tool than with the command line alternative, but the time required to learn how to effectively customize the Visual Profiler to obtain all the information required by the programmer may be prohibitive when compared with the other profiling tools.

\subsubsection{PAPI CUDA}
\label{sec:534}

% \todopfac{referir entre outras coisas que foi preciso usar o cupti (a callbacks api) para trabalhar com o papi cuda, embora seja suposto ser um wrapper para ele}

% \todonaps{usar primeiro o sample, falar depois}

The PAPI CUDA interface does not stand better than any of the alternatives above. Its place in the software layers stands between the CUPTI low level API and the Command Line Profiler high level functionalities.

This interface allows a user with low or no knowledge of the CUDA programming model to measure a specific kernel called by the host, simply by initializing the library, event set and by starting the measurement. The API is the same as used with any C/C++ application to run only in the host, it only differs in the hardware counter used (specific components have specific counters).

PAPI CUDA is supposed to be a wrapper for the CUPTI API, thus allowing low level operations to be performed in an easier fashion. Yet, the tests performed showed that it lacks the functionalities of CUPTI events. In fact, the best way to use the interface is by using these events to start/stop it precisely at the entrance/exit of the kernel.

On a last remark, one of the worst defects with the PAPI interface in general is the necessity for a great amount of code to be placed to prepare it and cleanup after it. This characteristic remains the same with PAPI CUDA. CUPTI is not so verbose, and is, therefore, more convenient to use, providing the same functionalities.
